import torch
import torch.nn as nn
import torch.nn.functional as F

class VAE(nn.Module):

  class Encoder(nn.Module): 
    """
    The encoder takes at point in image space and maps it to not a point, 
    but a distribution p(z|x) in the latent space, this is called the posterior
    distribution, which is intractable. In Kingma's paper, he just simplified 
    it to be a diagonal Gaussian q_phi (z|x), but in reality this can be anything. 
    """

    def __init__(self, idim, hdim, odim): 
      super().__init__()
      self.odim = odim
      self.fc1 = nn.Linear(idim, hdim)
      self.fc21 = nn.Linear(hdim, odim)
      self.fc22 = nn.Linear(hdim, odim) 

    def forward(self, x): 
      h1 = F.relu(self.fc1(x))
      return self.fc21(h1), self.fc22(h1) # \mu, \logvar(\sigma^2)

  class Decoder(nn.Module): 
    """
    Decoder takes a point generated by the distribution in the latent space, 
    and maps it back to image space. 
    """

    def __init__(self, idim, hdim, odim): 
      super().__init__()
      self.fc1 = nn.Linear(idim, hdim)
      self.fc2 = nn.Linear(hdim, odim)

    def forward(self, z): 
      h3 = F.relu(self.fc1(z))
      return torch.sigmoid(self.fc2(h3))

  def __init__(self, idim, hdim, zdim, device):
    super().__init__()
    self.encoder = self.Encoder(idim, hdim, zdim)
    self.decoder = self.Decoder(zdim, hdim, idim)
    self.device = device
    self.to(device)

  def encode(self, x): return self.encoder(x) 
  def decode(self, z): return self.decoder(z)

  def reparameterize(self, mu, logvar):
    """
    Sample a point from p(z|x), which is a Gaussian RV
    """
    stdev = torch.exp(0.5*logvar)
    eps = torch.randn_like(stdev)
    return mu + eps*stdev

  def forward(self, x):
    """
    1. Encode x to compute conditional distribution q_phi (z|x) 
    2. Sample from p(z|x) using reparameterization trick. 
    3. Decode to get p(x|z). 
    Just a composition of the encoder, reparamterization, and decoding. 
    """
    mu, logvar = self.encoder(x)
    z = self.reparameterize(mu, logvar)
    return self.decoder(z), mu, logvar


